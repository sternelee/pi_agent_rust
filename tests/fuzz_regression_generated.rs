// AUTO-GENERATED by scripts/fuzz_crash_manage.sh generate-tests
// DO NOT EDIT BY HAND.

use pi::sse::SseParser;

fn assert_sse_chunking_invariant(data: &[u8]) {
    let input = String::from_utf8_lossy(data);

    let mut parser_whole = SseParser::new();
    let events_whole = parser_whole.feed(&input);
    let flush_whole = parser_whole.flush();

    let mut parser_char = SseParser::new();
    let mut events_char = Vec::new();
    for ch in input.chars() {
        let mut buf = [0u8; 4];
        let s = ch.encode_utf8(&mut buf);
        events_char.extend(parser_char.feed(s));
    }
    let flush_char = parser_char.flush();

    if input.len() >= 2 {
        let mid = input.len() / 2;
        let mut split_at = mid;
        while !input.is_char_boundary(split_at) && split_at < input.len() {
            split_at += 1;
        }
        let (part1, part2) = input.split_at(split_at);
        let mut parser_split = SseParser::new();
        let mut events_split = parser_split.feed(part1);
        events_split.extend(parser_split.feed(part2));
        let flush_split = parser_split.flush();

        assert_eq!(
            events_whole.len(),
            events_split.len(),
            "whole/split event count mismatch"
        );
        for (idx, (whole, split)) in events_whole.iter().zip(events_split.iter()).enumerate() {
            assert_eq!(whole, split, "whole/split event mismatch at index {idx}");
        }
        assert_eq!(flush_whole, flush_split, "whole/split flush mismatch");
    }

    assert_eq!(
        events_whole.len(),
        events_char.len(),
        "whole/char event count mismatch"
    );
    for (idx, (whole, ch)) in events_whole.iter().zip(events_char.iter()).enumerate() {
        assert_eq!(whole, ch, "whole/char event mismatch at index {idx}");
    }
    assert_eq!(flush_whole, flush_char, "whole/char flush mismatch");
}

fn run_regression_case(target: &str, data: &[u8], path: &str) {
    match target {
        "fuzz_smoke" => assert!(
            !data.is_empty(),
            "regression input must not be empty: {path}"
        ),
        "fuzz_sse_parser" => assert_sse_chunking_invariant(data),
        _ => panic!("missing regression target handler for {target} (file {path})"),
    }
}

#[test]
fn regression_fuzz_smoke_unknown_001() {
    // target=fuzz_smoke, category=unknown
    let data = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/fuzz/regression/fuzz_smoke/unknown-001.bin"
    ));
    run_regression_case(
        "fuzz_smoke",
        data,
        "fuzz/regression/fuzz_smoke/unknown-001.bin",
    );
}

#[test]
fn regression_fuzz_sse_parser_harness_false_positive_001() {
    // target=fuzz_sse_parser, category=unknown
    let data = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/fuzz/regression/fuzz_sse_parser/harness-false-positive-001.bin"
    ));
    run_regression_case(
        "fuzz_sse_parser",
        data,
        "fuzz/regression/fuzz_sse_parser/harness-false-positive-001.bin",
    );
}

#[test]
fn regression_fuzz_sse_parser_panic_unwrap_001() {
    // target=fuzz_sse_parser, category=unknown
    let data = include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/fuzz/regression/fuzz_sse_parser/panic-unwrap-001.bin"
    ));
    run_regression_case(
        "fuzz_sse_parser",
        data,
        "fuzz/regression/fuzz_sse_parser/panic-unwrap-001.bin",
    );
}
